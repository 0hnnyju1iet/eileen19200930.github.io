<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我们需要被讨厌的勇气</title>
    <url>/2020/07/17/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B/</url>
    <content><![CDATA[<h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>我一般习惯在电子产品上读书，每当一个礼拜过去，app都会发布一周内我读书花了多少时间，有个很有意思的现象是：在忙碌的一周，我往往会读书大概5-6个小时，而在无所事事的一周，大概是1-2个小时。想想理由也很简单，无非是忙碌时读书相比手头的事物是一件美差事，就“见缝插针”地主动去读；而在空闲时读书相比娱乐美食睡觉是一件“食之无味，弃之可惜”的事，就不那么情愿去读。所以对于我来说，在忙碌期读的书印象反而很深。这段时间在学自己不太擅长的英语，有时深感枯燥，所以在看《被讨厌的勇气》时印象特别深。在最初看到这本书的题目时，我是不太理解什么叫“被讨厌的勇气”的，并且“勇气”这个词好像有点俗套，就带着看鸡汤文的心态翻了几页，没想到全部看完了以后，也没有产生“你说的倒好听”的想法。（前段时间还看过柏拉图的《理想国》，或许是年代久远，或者是因为文化氛围不同，不太能get到共鸣，而这本出自日本的著作就好很多）于是想把这本书的主要观点记录下来，以便万一哪天想到了可以回来看看此时的心情。</p>
<h3 id="◆-引言"><a href="#◆-引言" class="headerlink" title="◆ 引言"></a>◆ 引言</h3><blockquote>
<p>幸福的浪漫主义季节转瞬即逝，残酷的现实主义时代终将到来。</p>
</blockquote>
<blockquote>
<p>如果是在宗教盛行的时代，人们也还有救。那时，神的旨意就是真理、就是世界、就是一切，只要遵从神的旨意，需要思考的课题也就很少。</p>
</blockquote>
<blockquote>
<p>人并不是住在客观的世界，而是住在自己营造的主观世界里。你所看到的世界不同于我所看到的世界，而且恐怕是不可能与任何人共有的世界。</p>
</blockquote>
<blockquote>
<p>现在，你眼中的世界呈现出复杂怪异的一片混沌。但是，如果你自身发生了变化，世界就会恢复其简单姿态。因为，问题不在于世界如何，而在于你自己怎样。</p>
</blockquote>
<blockquote>
<p>摘掉墨镜之后看到的世界也许会太过耀眼，而使你禁不住闭上眼睛。或许你又会想念墨镜。即便如此，你依然能够摘掉墨镜吗？你能正视这个世界吗？你有这种“勇气”吗？问题就在这里。</p>
</blockquote>
<h3 id="◆-第一夜-我们的不幸是谁的错？"><a href="#◆-第一夜-我们的不幸是谁的错？" class="headerlink" title="◆ 第一夜 我们的不幸是谁的错？"></a>◆ 第一夜 我们的不幸是谁的错？</h3><blockquote>
<p>青年自幼就缺乏自信，他对自己的出身、学历甚至容貌都抱有强烈的自卑感。也许是因为这样，他往往过于在意他人的目光；而且，他无法衷心地去祝福别人的幸福，从而常常陷入自我嫌恶的痛苦境地。</p>
</blockquote>
<h5 id="◆-不为人知的心理学“第三巨头”"><a href="#◆-不为人知的心理学“第三巨头”" class="headerlink" title="◆ 不为人知的心理学“第三巨头”"></a>◆ 不为人知的心理学“第三巨头”</h5><blockquote>
<p>阿德勒是与弗洛伊德、荣格并列的三大巨头之一。</p>
</blockquote>
<h5 id="◆-再怎么“找原因”，也没法改变一个人"><a href="#◆-再怎么“找原因”，也没法改变一个人" class="headerlink" title="◆ 再怎么“找原因”，也没法改变一个人"></a>◆ 再怎么“找原因”，也没法改变一个人</h5><blockquote>
<p>如果一味地关注过去的原因，企图仅仅靠原因去解释事物，那就会陷入“决定论”。也就是说，最终会得出这样的结论：我们的现在甚至未来全部都由过去的事情所决定，而且根本无法改变。是这样吧？</p>
</blockquote>
<blockquote>
<p>是的，那样的确讲不通。所以，阿德勒心理学考虑的不是过去的“原因”，而是现在的“目的”。</p>
</blockquote>
<blockquote>
<p>德勒心理学把这叫作“目的论”。</p>
</blockquote>
<p>这是出现的第一个重要观点，即解释同一事物，可以有“原因论”和“目的论”两种方式。这并不难理解，只是需要长期练习来使自己变得更乐观。举个例子的话：我学习雅思课，但学的很差，我会说：“我英语不好的原因是我从小就对英语不感兴趣。学的不好”这就是原因论，先承认自己学不好的事实，再给自己找原因；而如果是：我先有了不想学习英语的念头，继而有目的地制造出自己英语不好的感觉。这就是目的论，是自己主动断绝了学好英语的可能性。这两个乍一看差不多，但产生的后果是截然不同的。如果你信奉原因论，那么就陷入了“决定论”的泥淖，不管发生什么都会找到一个决定性的因素来说服自己；但如果能意识到目的论的运作机制，就会明白自己并非是学不好英语，而是自己大脑习惯于让自己活得舒服点，这就为成功提供了可能性。</p>
<h5 id="◆心理创伤并不存在"><a href="#◆心理创伤并不存在" class="headerlink" title="◆心理创伤并不存在"></a>◆心理创伤并不存在</h5><blockquote>
<p>但是，立足于原因论的人们，例如一般的生活顾问或者精神科医生，仅仅会指出“你之所以痛苦是因为过去的事情”，继而简单地安慰“所以错不在你”。所谓的心理创伤学说就是原因论的典型。</p>
</blockquote>
<blockquote>
<p>任何经历本身并不是成功或者失败的原因。我们并非因为自身经历中的刺激——所谓的心理创伤——而痛苦，事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义</p>
</blockquote>
<blockquote>
<p>那么，请你站在父母的角度想一想。如果自己的孩子总是闷在房间里，你会怎么想呢？<br>青年：那当然会担心啦。如何能让他回归社会？如何能令其振作精神？自己的教育方式是否有误？一定会绞尽脑汁地思考诸如此类的问题。同时，也一定会想方设法地帮助他回归社会。<br>哲人：问题就在这里。<br>青年：哪里？<br>哲人：如果闭门不出一直憋在自己房间里的话，父母会非常担心。这就可以把父母的关注集于一身，而且还可以得到父母小心翼翼的照顾。<br>另一方面，哪怕踏出家门一步，都会沦为无人关注的“大多数”，都会成为茫茫人海中非常平凡的一员，甚至成为逊色于人的平庸之辈；而且，没人会重视自己。这些都是闭居者常有的心理。</p>
</blockquote>
<h5 id="◆-愤怒都是捏造出来的"><a href="#◆-愤怒都是捏造出来的" class="headerlink" title="◆ 愤怒都是捏造出来的"></a>◆ 愤怒都是捏造出来的</h5><blockquote>
<p>昨天下午我在咖啡店看书的时候，从我身边经过的服务员不小心把咖啡洒到了我的衣服上。那可是我刚刚下狠心买的一件好衣服啊。勃然大怒的我忍不住大发雷霆。平时的我从不在公共场合大声喧哗，唯独昨天，我愤怒的声音几乎传遍了店里的每一个角落。我想那应该是因为过于愤怒而忘记了自我吧。您看，在这种情况下，“目的”还能讲得通吗？无论怎么想，这都是“原因”导致的行为吧？</p>
</blockquote>
<blockquote>
<p>所谓愤怒其实只是可放可收的一种“手段”而已。它既可以在接电话的瞬间巧妙地收起，也可以在挂断电话之后再次释放出来。</p>
</blockquote>
<h5 id="◆-弗洛伊德说错了"><a href="#◆-弗洛伊德说错了" class="headerlink" title="◆ 弗洛伊德说错了"></a>◆ 弗洛伊德说错了</h5><blockquote>
<p>人并不受过去的原因所左右，而是朝着自己定下的目标前进，这就是哲人的主张。哲人所倡导的“目的论”是一种彻底颠覆正统心理学中的因果论的思想，这对青年来说根本无法接受。那么，该从何处破论呢？青年深吸了一口气。</p>
</blockquote>
<h5 id="◆-苏格拉底和阿德勒"><a href="#◆-苏格拉底和阿德勒" class="headerlink" title="◆ 苏格拉底和阿德勒"></a>◆ 苏格拉底和阿德勒</h5><blockquote>
<p>为什么那么急于得到答案呢？答案不应该是从别人那里得到，而应该是自己亲自找出来。从别人那里得到的答案只不过是对症疗法而已，没有什么价值。</p>
</blockquote>
<h5 id="◆-你想“变成别人”吗？"><a href="#◆-你想“变成别人”吗？" class="headerlink" title="◆ 你想“变成别人”吗？"></a>◆ 你想“变成别人”吗？</h5><blockquote>
<p>哲人：那么我来问你，你究竟为什么想要成为Y那样的人呢？Y也好，其他什么人也好，总之你想变成别人，其“目的”是什么呢？</p>
</blockquote>
<blockquote>
<p>面对喜不喜欢自己这个问题，能够坦然回答“喜欢”的人几乎没有。</p>
</blockquote>
<blockquote>
<p>至少我不想变成别人，也能悦纳目前的自己。</p>
</blockquote>
<blockquote>
<p>重要的不是被给予了什么，而是如何去利用被给予的东西。</p>
</blockquote>
<h5 id="◆-你的不幸，皆是自己“选择”的"><a href="#◆-你的不幸，皆是自己“选择”的" class="headerlink" title="◆ 你的不幸，皆是自己“选择”的"></a>◆ 你的不幸，皆是自己“选择”的</h5><blockquote>
<p>你知道“无人想作恶”这句话吗？一般它都是作为苏格拉底的悖论而为人们所了解的一个命题。</p>
</blockquote>
<h5 id="◆-人们常常下定决心“不改变”"><a href="#◆-人们常常下定决心“不改变”" class="headerlink" title="◆ 人们常常下定决心“不改变”"></a>◆ 人们常常下定决心“不改变”</h5><blockquote>
<p>要想改变生活方式需要很大的“勇气”。面对变化产生的“不安”与不变带来的“不满”，你一定是选择了后者。</p>
</blockquote>
<blockquote>
<p>是的，阿德勒心理学就是勇气心理学。你之所以不幸并不是因为过去或者环境，更不是因为能力不足，你只不过是缺乏“勇气”，可以说是缺乏“获得幸福的勇气”。</p>
</blockquote>
<h5 id="◆-你的人生取决于“当下”"><a href="#◆-你的人生取决于“当下”" class="headerlink" title="◆ 你的人生取决于“当下”"></a>◆ 你的人生取决于“当下”</h5><blockquote>
<p>实际上，他是想通过不去比赛这一方式来保留一种“如果做的话我也可以”的可能性，即不愿出去被人评价，更不愿去面对因作品拙劣而落选的现实</p>
</blockquote>
<blockquote>
<p>阿德勒的目的论是说：“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。</p>
</blockquote>
<h5 id="◆-为什么讨厌自己？"><a href="#◆-为什么讨厌自己？" class="headerlink" title="◆ 为什么讨厌自己？"></a>◆ 为什么讨厌自己？</h5><blockquote>
<p>承认就是很了不起的态度。但是，请你不要忘记，在人际关系中根本不可能不受伤。只要涉入人际关系就会或大或小地受伤，也会伤害别人。阿德勒曾说“要想消除烦恼，只有一个人在宇宙中生存”。但是，那种事情根本就无法做到。</p>
</blockquote>
<h5 id="◆-一切烦恼都是人际关系的烦恼"><a href="#◆-一切烦恼都是人际关系的烦恼" class="headerlink" title="◆ 一切烦恼都是人际关系的烦恼"></a>◆ 一切烦恼都是人际关系的烦恼</h5><blockquote>
<p>之所以感觉孤独并不是因为只有你自己一个人，感觉自己被周围的他人、社会和共同体所疏远才会孤独。我们要想体会孤独也需要有他人的存在。也就是说，人只有在社会关系中才会成为“个人”。</p>
</blockquote>
<h5 id="◆-自卑情结只是一种借口"><a href="#◆-自卑情结只是一种借口" class="headerlink" title="◆ 自卑情结只是一种借口"></a>◆ 自卑情结只是一种借口</h5><blockquote>
<p>阿德勒也承认自卑感人人都有。自卑感本身并不是什么坏事</p>
</blockquote>
<blockquote>
<p>那么，人究竟为什么会有自卑感呢？<br>哲人：这需要从头说起。首先，人是作为一种无力的存在活在这个世界上。并且，人希望摆脱这种无力状态，继而就有了普遍欲求。阿德勒称其为“追求优越性”。<br>青年：追求优越性？<br>哲人：在这里，你可以简单将其理解为“希望进步”或者“追求理想状态”。例如，蹒跚学步的孩子学会独自站立；他们学会语言，可以与周围的人自由沟通。我们都有想要摆脱无力状态、追求进步的普遍欲求。人类史上的科学进步也是“追求优越性”的结果。<br>青年：确实如此。那么？<br>哲人：与此相对应的就是自卑感。人都处于追求优越性这一“希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。例如，越是有远大志向的厨师也许就越会产生“还很不熟练”或者“必须做出更好的料理”之类的自卑感。</p>
</blockquote>
<blockquote>
<p>而另一方面，自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。像这样在日常生活中大肆宣扬“因为有A所以才做不到B”这样的理论，这已经超出了自卑感的范畴，它是一种自卑情结。</p>
</blockquote>
<blockquote>
<p>简单地说就是害怕向前迈进或者是不想真正地努力。不愿意为了改变自我而牺牲目前所享受的乐趣——比如玩乐或休闲时间。也就是拿不出改变生活方式的“勇气”，即使有些不满或者不自由，也还是更愿意维持现状。</p>
</blockquote>
<h5 id="◆-越自负的人越自卑"><a href="#◆-越自负的人越自卑" class="headerlink" title="◆ 越自负的人越自卑"></a>◆ 越自负的人越自卑</h5><blockquote>
<p>是的。以自己的不幸为武器来支配对方。通过诉说自己如何不幸、如何痛苦来让周围的人——比如家人或朋友——担心或束缚支配其言行。刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。”</p>
</blockquote>
<h5 id="◆-人生不是与他人的比赛"><a href="#◆-人生不是与他人的比赛" class="headerlink" title="◆ 人生不是与他人的比赛"></a>◆ 人生不是与他人的比赛</h5><blockquote>
<p>不，既不当作成人来对待也不当作孩子来对待，而是“当作人”来对待。把孩子当作与自己一样的一个人来真诚相对。</p>
</blockquote>
<h5 id="◆-在意你长相的，只有你自己"><a href="#◆-在意你长相的，只有你自己" class="headerlink" title="◆ 在意你长相的，只有你自己"></a>◆ 在意你长相的，只有你自己</h5><blockquote>
<p>哲人：这与竞争有关。请你记住。如果在人际关系中存在“竞争”，那人就不可能摆脱人际关系带来的烦恼，也就不可能摆脱不幸。</p>
</blockquote>
<blockquote>
<p>也就是会认为人人都是随时会愚弄、嘲讽、攻击甚至陷害自己、绝不可掉以轻心的敌人，而世界则是一个恐怖的地方。</p>
</blockquote>
<blockquote>
<p>我有一位年轻的朋友，据说他少年时代总是长时间对着镜子整理头发。于是，他祖母对他说：“在意你的脸的只有你自己。”那之后，他便活得轻松了一些。</p>
</blockquote>
<blockquote>
<p>我有时候这样想。自己就像是从未真正沐浴过阳光的丝瓜，自然就会因为自卑感而扭曲。所以，如果有挺拔舒展的人，真希望他能够带带我呀！</p>
</blockquote>
<blockquote>
<p>你刚刚也说过吧？“无法真心祝福过得幸福的他人”，那就是因为站在竞争的角度来考虑人际关系，把他人的幸福看作“我的失败”，所以才无法给予祝福。</p>
</blockquote>
<blockquote>
<p>由严厉父母养大的青年自幼便一直被拿来与哥哥进行比较，并受到不公正的待遇；任何意见都不被采纳，还被骂作是差劲的弟弟；在学校也交不到朋友，休息时间也一直闷在图书室里，只有图书室是自己的安身之所。经历过这种少年时代的青年彻底成了原因论的信徒。他认为，如果没有那样的父母和哥哥、没有在那样的学校上学的话，自己也会有一个更加光明的人生。原本想要尽可能地冷静辩论的青年积累了多年的情绪，在此时一下子爆发了。</p>
</blockquote>
<h5 id="◆-人际关系中的“权力斗争”与复仇"><a href="#◆-人际关系中的“权力斗争”与复仇" class="headerlink" title="◆ 人际关系中的“权力斗争”与复仇"></a>◆ 人际关系中的“权力斗争”与复仇</h5><blockquote>
<p>这种情况下，对方的目的是什么呢？是纯粹想要讨论政治吗？不是。对方只是想要责难挑衅你，通过权力之争来达到让不顺眼的你屈服的目的。这个时候你如果发怒的话，那就是正中其下怀，关系会急剧转入权力之争。所以，我们不能上任何挑衅的当。</p>
</blockquote>
<blockquote>
<p>为了避免这一点，在受到争权挑衅时绝对不可以上当。</p>
</blockquote>
<h5 id="◆-承认错误，不代表你失败了"><a href="#◆-承认错误，不代表你失败了" class="headerlink" title="◆ 承认错误，不代表你失败了"></a>◆ 承认错误，不代表你失败了</h5><blockquote>
<p>“忍耐”这种想法本身就表明你依然拘泥于权力之争。而是要对对方的行为不做任何反应。我们能做的就只有这一点。</p>
</blockquote>
<blockquote>
<p>所谓控制怒气是否就是“忍耐”呢？不是的，我们应该学习不使用怒气这种感情的方法，因为怒气终归是为了达成目的的一种手段和工具。</p>
</blockquote>
<blockquote>
<p>易怒的人并不是性情急躁，而是不了解发怒以外的有效交流工具。所以才会说“不由得发火”之类的话。这其实是在借助发怒来进行交流。</p>
</blockquote>
<blockquote>
<p>关于权力之争，还有一点需要注意。那就是无论认为自己多么正确，也不要以此为理由去责难对方。这是很多人都容易陷落进去的人际关系圈套。</p>
</blockquote>
<blockquote>
<p>人在人际关系中一旦确信“我是正确的”，那就已经步入了权力之争。</p>
</blockquote>
<h5 id="◆-人生的三大课题：交友课题、工作课题以及爱的课题"><a href="#◆-人生的三大课题：交友课题、工作课题以及爱的课题" class="headerlink" title="◆ 人生的三大课题：交友课题、工作课题以及爱的课题"></a>◆ 人生的三大课题：交友课题、工作课题以及爱的课题</h5><blockquote>
<p>首先，行为方面的目标有“自立”和“与社会和谐共处”这两点。而且，支撑这种行为的心理方面的目标是“我有能力”以及“人人都是我的伙伴”这两种意识。</p>
</blockquote>
<blockquote>
<p>更讨厌无可替代的“我”的尊严受到伤害。</p>
</blockquote>
<h5 id="◆-浪漫的红线和坚固的锁链"><a href="#◆-浪漫的红线和坚固的锁链" class="headerlink" title="◆ 浪漫的红线和坚固的锁链"></a>◆ 浪漫的红线和坚固的锁链</h5><blockquote>
<p>当时老师好像说：“不必担心。他是不需要朋友的人。”老师的话给了母亲和我极大的勇气。</p>
</blockquote>
<blockquote>
<p>人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。</p>
</blockquote>
<blockquote>
<p>假如恋爱是用红色丝线系起来的关系的话，那亲子关系就是用坚固的锁链联结起来的关系。而且，自己手里只有一把小小的剪刀。亲子关系难就难在这里。</p>
</blockquote>
<h5 id="◆-“人生谎言”教我们学会逃避"><a href="#◆-“人生谎言”教我们学会逃避" class="headerlink" title="◆ “人生谎言”教我们学会逃避"></a>◆ “人生谎言”教我们学会逃避</h5><blockquote>
<p>在恋爱或夫妻关系中，过了某个时期之后，有时候对方的任何言行都会让你生气。吃饭的方式让你不满意，在房间里的散漫姿态令你生厌，甚至就连对方睡眠时的呼吸声都让你生气，尽管几个月前还不是这样。</p>
</blockquote>
<blockquote>
<p>这是因为那个人已经下定决心要找机会“结束这种关系”，继而正在搜集结束关系的材料，所以才会那样感觉。对方其实没有任何改变，只是自己的“目的”变了而已。</p>
</blockquote>
<blockquote>
<p>那就是，决定你的生活方式（人生状态）的不是其他任何人，而是你自己这一事实。</p>
</blockquote>
<h5 id="◆-阿德勒心理学是“勇气的心理学”"><a href="#◆-阿德勒心理学是“勇气的心理学”" class="headerlink" title="◆ 阿德勒心理学是“勇气的心理学”"></a>◆ 阿德勒心理学是“勇气的心理学”</h5><blockquote>
<p>也就是“不在于被给予了什么，而在于如何去使用被给予的东西”那句话吗？</p>
</blockquote>
<blockquote>
<p>是的，你记得很清楚嘛。弗洛伊德式的原因论是“拥有的心理学”，继而就会转入决定论。另一方面，阿德勒心理学是“使用的心理学”，起决定作用的是你自己。</p>
</blockquote>
<h5 id="◆-自由就是不再寻求认可？"><a href="#◆-自由就是不再寻求认可？" class="headerlink" title="◆ 自由就是不再寻求认可？"></a>◆ 自由就是不再寻求认可？</h5><blockquote>
<p>就是：“货币是被铸造的自由。”它是陀思妥耶夫斯基的小说中出现的一句话。“被铸造的自由”这种说法是何等的痛快啊！我认为这是一句非常精辟的话，它一语道破了货币的本质。</p>
</blockquote>
<blockquote>
<p>在上大学之前，我一直认为不能无视父母的意愿，所以总是既烦恼又反感。但事实上，我在不知不觉间就把自己的希望和父母的希望重合在了一起。虽然工作是按照自己的意愿选的。</p>
</blockquote>
<blockquote>
<p>阿德勒心理学否定寻求他人的认可。</p>
</blockquote>
<h5 id="◆-要不要活在别人的期待中？"><a href="#◆-要不要活在别人的期待中？" class="headerlink" title="◆ 要不要活在别人的期待中？"></a>◆ 要不要活在别人的期待中？</h5><blockquote>
<p>在犹太教教义中有这么一句话：“倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？</p>
</blockquote>
<h5 id="◆-把自己和别人的“人生课题”分开来"><a href="#◆-把自己和别人的“人生课题”分开来" class="headerlink" title="◆ 把自己和别人的“人生课题”分开来"></a>◆ 把自己和别人的“人生课题”分开来</h5><blockquote>
<p>基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。只要能够进行课题分离，人际关系就会发生巨大改变。</p>
</blockquote>
<h5 id="◆-放下别人的课题，烦恼轻轻飞走"><a href="#◆-放下别人的课题，烦恼轻轻飞走" class="headerlink" title="◆ 放下别人的课题，烦恼轻轻飞走"></a>◆ 放下别人的课题，烦恼轻轻飞走</h5><blockquote>
<p>而且，不去干涉别人的课题也不让别人干涉自己的课题。这就是阿德勒心理学给出的具体而且有可能彻底改变人际关系烦恼的具有划时代意义的观点。</p>
</blockquote>
<h5 id="◆-对认可的追求，扼杀了自由"><a href="#◆-对认可的追求，扼杀了自由" class="headerlink" title="◆ 对认可的追求，扼杀了自由"></a>◆ 对认可的追求，扼杀了自由</h5><blockquote>
<p>我一直都心怀不满！世上的长者们常常会对年轻人说：“做自己喜欢做的事！”而且说这话的时候脸上还带着像理解者或者是朋友般的笑。但是，这样的话恐怕也就对那些跟自己没有什么关系也不必负责任的陌生年轻人说说而已吧！</p>
</blockquote>
<blockquote>
<p>选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。</p>
</blockquote>
<h5 id="◆-自由就是被别人讨厌"><a href="#◆-自由就是被别人讨厌" class="headerlink" title="◆ 自由就是被别人讨厌"></a>◆ 自由就是被别人讨厌</h5><blockquote>
<p>不想被别人讨厌，这对人而言是非常自然的欲望和冲动。近代哲学巨人康德把这种欲望称作“倾向性”。</p>
</blockquote>
<blockquote>
<p>“自由就是被别人讨厌”。</p>
</blockquote>
<blockquote>
<p>不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由。</p>
</blockquote>
<blockquote>
<p>获得幸福的勇气也包括“被讨厌的勇气”。一旦拥有了这种勇气，你的人际关系也会一下子变得轻松起来。</p>
</blockquote>
<h5 id="◆-人际关系“王牌”，握在你自己手里"><a href="#◆-人际关系“王牌”，握在你自己手里" class="headerlink" title="◆ 人际关系“王牌”，握在你自己手里"></a>◆ 人际关系“王牌”，握在你自己手里</h5><blockquote>
<p>是的。对我来说，不修复与父亲之间的关系更合适，因为如果自己的人生不顺利就可以归咎于父亲。这其中有对我来说的“善”，也许还有对封建的父亲的“报复”。</p>
</blockquote>
<h5 id="◆-人际关系的终极目标"><a href="#◆-人际关系的终极目标" class="headerlink" title="◆ 人际关系的终极目标"></a>◆ 人际关系的终极目标</h5><blockquote>
<p>那么，我来问一下。在这里请您只简单地回答结论。先生您说课题分离是人际关系的出发点。那么，人际关系的“终点”在哪里呢？<br>哲人：如果只回答结论的话，那就是“共同体感觉”。</p>
</blockquote>
<p>人类命运共同体的英文是a community of a shared future for human，一个可分享的未来</p>
<blockquote>
<p>在英语中，共同体感觉叫作“social interest”，也就是“对社会的关心”。</p>
</blockquote>
<blockquote>
<p>把对自己的执著（self interest）变成对他人的关心（social interest）。</p>
</blockquote>
<h5 id="◆-“拼命寻求认可”反而是以自我为中心？"><a href="#◆-“拼命寻求认可”反而是以自我为中心？" class="headerlink" title="◆ “拼命寻求认可”反而是以自我为中心？"></a>◆ “拼命寻求认可”反而是以自我为中心？</h5><blockquote>
<p>哲人：请你考虑一下认可欲求的实质——他人如何关注自己、如何评价自己？又在多大程度上满足自己的欲求？受这种认可欲求束缚的人看似在看着他人，但实际上眼里却只有自己。失去了对他人的关心而只关心“我”，也就是以自我为中心。</p>
</blockquote>
<blockquote>
<p>那么，也就是说像我这样非常在意别人评价的人也是以自我为中心吗？虽然如此竭尽全力地在迎合他人？！<br>哲人：是的。在只关心“我”这个意义上来讲，是以自我为中心。你正因为不想被他人认为自己不好，所以才在意他人的视线。这不是对他人的关心，而是对自己的执著。<br>青年：但是……<br>哲人：上一次我也说过。有人认为你不好，那证明你活得自由，或许从中能感到以自我为中心的气息。但是，我们现在要讨论的不是这一点。一味在意“他人怎么看”的生活方式正是只关心“我”的自我中心式的生活方式。</p>
</blockquote>
<h5 id="◆-你不是世界的中心，只是世界地图的中心"><a href="#◆-你不是世界的中心，只是世界地图的中心" class="headerlink" title="◆ 你不是世界的中心，只是世界地图的中心"></a>◆ 你不是世界的中心，只是世界地图的中心</h5><blockquote>
<p>但是，无论是你还是我，我们都不是世界的中心，必须用自己的脚主动迈出一步去面对人际关系课题；不是考虑“这个人会给我什么”，而是要必须思考一下“我能给这个人什么”。这就是对共同体的参与和融入。</p>
</blockquote>
<h5 id="◆-在更广阔的天地寻找自己的位置"><a href="#◆-在更广阔的天地寻找自己的位置" class="headerlink" title="◆ 在更广阔的天地寻找自己的位置"></a>◆ 在更广阔的天地寻找自己的位置</h5><blockquote>
<p>如果了解了世界之大，就会明白自己在学校中所受的苦只不过是“杯中风暴”而已。只要跳出杯子，猛烈的风暴也会变成微风。</p>
</blockquote>
<blockquote>
<p>是的，的确不简单。这里有需要记住的行动原则。当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是“倾听更大共同体的声音”这一原则。</p>
</blockquote>
<blockquote>
<p>不，这也可以拿“我和你”的关系来进行说明，如果是因为你的反对就能崩塌的关系，那么这种关系从一开始就没有必要缔结，由自己主动舍弃也无所谓。活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。</p>
</blockquote>
<blockquote>
<p>当然。没必要固执于眼前的小共同体。更多其他的“我和你”、更多其他的“大家”、更多大的共同体一定存在。</p>
</blockquote>
<h5 id="◆-批评不好……表扬也不行？"><a href="#◆-批评不好……表扬也不行？" class="headerlink" title="◆ 批评不好……表扬也不行？"></a>◆ 批评不好……表扬也不行？</h5><blockquote>
<p>那句“不错嘛，你做得很好”中所包含的俯视般的语感让人不愉快。</p>
</blockquote>
<blockquote>
<p>是的。表扬这种行为含有“有能力者对没能力者所做的评价”这方面的特点。有的母亲会赞美帮忙准备晚饭的孩子说“你真了不起”。但是，如果是丈夫做了同样的事情则一般不会表扬说“你真了不起”吧。</p>
</blockquote>
<blockquote>
<p>：嗯，的确。我在想要表扬他人的时候，心中多少也会有些“操纵”意识。企图通过说一些恭维的话来讨好上司，这也完全是一种操纵吧。反过来说，我自己也因为被某人表扬而被操纵着。呵呵呵，人就是这么回事吧！</p>
</blockquote>
<h5 id="◆-有鼓励才有勇气"><a href="#◆-有鼓励才有勇气" class="headerlink" title="◆ 有鼓励才有勇气"></a>◆ 有鼓励才有勇气</h5><blockquote>
<p>哲人：不对。假如你会因为得到表扬而感到喜悦，那就等于是从属于纵向关系和承认“自己没能力”。因为表扬是“有能力的人对没能力的人所作出的评价”。</p>
</blockquote>
<h5 id="◆-有价值就有勇气"><a href="#◆-有价值就有勇气" class="headerlink" title="◆ 有价值就有勇气"></a>◆ 有价值就有勇气</h5><blockquote>
<p>人怎样才能够获得“勇气”？阿德勒的见解是：人只有在能够感觉自己有价值的时候才可以获得勇气。</p>
</blockquote>
<h5 id="◆-只要存在着，就有价值"><a href="#◆-只要存在着，就有价值" class="headerlink" title="◆ 只要存在着，就有价值"></a>◆ 只要存在着，就有价值</h5><blockquote>
<p>不要这样，而应不将自己的孩子跟任何人相比，就把他看作他自己，对他的存在心怀喜悦与感激，不要按照理想形象去扣分，而是从零起点出发。如果是这样的话，那就能够对“存在”本身表示感谢了。</p>
</blockquote>
<h5 id="◆-第五夜-认真的人生“活在当下”"><a href="#◆-第五夜-认真的人生“活在当下”" class="headerlink" title="◆ 第五夜 认真的人生“活在当下”"></a>◆ 第五夜 认真的人生“活在当下”</h5><blockquote>
<p>阿德勒心理学彻底追问了人际关系，而且认为人际关系的最终目的是共同体感觉</p>
</blockquote>
<h5 id="◆-过多的自我意识，反而会束缚自己"><a href="#◆-过多的自我意识，反而会束缚自己" class="headerlink" title="◆ 过多的自我意识，反而会束缚自己"></a>◆ 过多的自我意识，反而会束缚自己</h5><blockquote>
<p>例如在开会的时候根本不敢举手发言，总是会因为担心“如果提这样的问题也许会被人笑话”或者“如果发表离题的意见也许会被人瞧不起”之类的问题而犹豫不决。哎呀，还不止如此，我甚至都不敢在人前开个小小的玩笑。自我意识总是牵绊着自己、严重束缚着自己的言行。我的自我意识根本不允许自己无拘无束地行动。</p>
</blockquote>
<h5 id="◆-不是肯定自我，而是接纳自我"><a href="#◆-不是肯定自我，而是接纳自我" class="headerlink" title="◆ 不是肯定自我，而是接纳自我"></a>◆ 不是肯定自我，而是接纳自我</h5><blockquote>
<p>还是共同体感觉。具体来说就是，把对自己的执著（self interest）转换成对他人的关心（social interest），建立起共同体感觉。这需要从以下三点做起：“自我接纳”“他者信赖”和“他者贡献”。</p>
</blockquote>
<blockquote>
<p>哲人：课题分离也是如此，要分清“能够改变的”和“不能改变的”。我们无法改变“被给予了什么”。但是，关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。这就是不去关注“无法改变的”，而是去关注“可以改变的”。这就是我所说的自我接纳。</p>
</blockquote>
<blockquote>
<p>上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别。”来自一部小说。<br>◆ 信用和信赖有何区别？</p>
</blockquote>
<blockquote>
<p>青年：他者信赖也就是相信他人吗？<br>哲人：在这里需要把“相信”这个词分成信用和信赖来区别考虑。首先，信用有附加条件，用英语讲就是“credit”。例如，想要从银行贷款，就必须提供某些抵押。银行会估算抵押价值然后贷给你相应的金额。“如果你还的话我就借给你”或是“只借给你能够偿还的份额”，这种态度并不是信赖，而是信用。<br>青年：是啊，银行融资本来就是这样嘛。<br>哲人：与此相对，阿德勒心理学认为人际关系的基础不应该是“信用”，而应该是“信赖”。<br>青年：这里的信赖是指什么呢？<br>哲人：在相信他人的时候不附加任何条件。即使没有足以构成信用的客观依据也依然相信，不考虑抵押之类的事情，无条件地相信。这就是信赖。<br>青年：无条件地相信？又是先生您津津乐道的邻人爱吗？<br>哲人：当然，无条件地相信他人有时也会遭遇背叛。就好比贷款保证人有时也会蒙受损失一样。即使如此却依然继续相信的态度就叫作信赖。<br>青年：这是缺心眼儿的老好人！先生也许支持性善说，但我却主张性恶说，无条件地相信陌生人会遭人利用！</p>
</blockquote>
<blockquote>
<p>悲伤的时候尽管悲伤就可以。因为，正是想要逃避痛苦或悲伤才不敢付诸行动，以至于与任何人都无法建立起深厚的关系。</p>
</blockquote>
<h5 id="◆-工作的本质是对他人的贡献"><a href="#◆-工作的本质是对他人的贡献" class="headerlink" title="◆ 工作的本质是对他人的贡献"></a>◆ 工作的本质是对他人的贡献</h5><blockquote>
<p>阿德勒把为他人牺牲自己人生的人称作“过度适应社会的人”，并对此给予警示。</p>
</blockquote>
<blockquote>
<p>但是，有些富豪已经拥有了一生也花不完的巨额财产，但他们中的多数人至今依然继续忙碌工作着。为什么要工作呢？是因为无底的欲望吗？不是。这是为了他者贡献继而获得“可以在这里的”归属感。获得巨额财富之后便致力于参加慈善活动的富豪们，也为了能够体会自我价值、确认“可以在这里”的归属感而进行着各种各样的活动。</p>
</blockquote>
<h5 id="◆-年轻人也有胜过长者之处"><a href="#◆-年轻人也有胜过长者之处" class="headerlink" title="◆ 年轻人也有胜过长者之处"></a>◆ 年轻人也有胜过长者之处</h5><blockquote>
<p>行为方面的目标：<br>①自立。<br>②与社会和谐共处。<br>支撑这种行为的心理方面的目标：<br>①“我有能力”的意识。<br>②“人人都是我的伙伴”的意识。</p>
</blockquote>
<blockquote>
<p>你还年轻，学得越早就越有可能早日改变。在能够早日改变这个意义上，你比世上的长者们都要超前一步。为了改变自己创造一个新的世界，在某种意义上你比我更超前。可以迷路也可以走偏，只要不再从属于纵向关系，不畏惧惹人讨厌地自由前行就可以。如果所有人都能够认为“年轻人更超前”的话，世界就会发生重大改变。</p>
</blockquote>
<h5 id="◆-“工作狂”是人生谎言"><a href="#◆-“工作狂”是人生谎言" class="headerlink" title="◆ “工作狂”是人生谎言"></a>◆ “工作狂”是人生谎言</h5><blockquote>
<p>哲人：的确，世上并非全是好人，人际关系中也会遭遇到诸多不愉快的事情。但是，在这里绝对不可以搞错这样一个事实：任何情况下都只是攻击我的“那个人”有问题，而绝不是“大家”的错。<br>具有神经质生活方式的人常常使用“大家”“总是”或者“一切”之类的词语。“大家都讨厌自己”“总是只有自己受损失”或者“一切都不对”等。</p>
</blockquote>
<blockquote>
<p>假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。</p>
</blockquote>
<blockquote>
<p>人际关系不顺利既不是因为口吃也不是因为脸红恐惧症，真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。</p>
</blockquote>
<blockquote>
<p>口吃者是只看事物的一部分便来判断其整体。与此相对，工作狂则是只关注人生特定的侧面。<br>也许他们会辩解说：“因为工作忙，所以无暇顾及家庭。”但是，这其实是人生的谎言。只不过是以工作为借口来逃避其他责任。本来家务、育儿、交友或兴趣应该全都给予关心，阿德勒不认可任何一方面突出的生活方式。</p>
</blockquote>
<blockquote>
<p>青年：……如此想来，我似乎能够理解先生上次所说的“存在标准”的意思了。我的确没有认真想过自己无法劳动、在“行为标准”上做不了任何事时候的情况。<br>哲人：是按照“行为标准”来接受自己还是按照“存在标准”来接受自己，这正是一个有关“获得幸福的勇气”的问题。</p>
</blockquote>
<h5 id="◆-从这一刻起，就能变得幸福"><a href="#◆-从这一刻起，就能变得幸福" class="headerlink" title="◆ 从这一刻起，就能变得幸福"></a>◆ 从这一刻起，就能变得幸福</h5><blockquote>
<p>对人而言，最大的不幸就是不喜欢自己。对于这种现实，阿德勒准备了极其简单的回答——“我对共同体有益”或者“我对他人有用”这种想法就足以让人体会到自己的价值。</p>
</blockquote>
<blockquote>
<p>人只有在能够感觉到“我对别人有用”的时候才能体会到自己的价值。但是，这种贡献也可以通过看不见的形式实现。只要有“对别人有用”的主观感觉，即“贡献感”就可以。并且，哲人还得出了这样的结论：幸福就是“贡献感”。的确，这也是真理的一面。但是，幸福就仅止于此吗？我所期待的幸福并不是这样的！</p>
</blockquote>
<h5 id="◆-追求理想者面前的两条路"><a href="#◆-追求理想者面前的两条路" class="headerlink" title="◆ 追求理想者面前的两条路"></a>◆ 追求理想者面前的两条路</h5><blockquote>
<p>无论是希望特别优秀还是希望特别差劲，其目的都一样——引起他人的关注、脱离“普通”状态、成为“特别的存在”。这就是他们的目的。</p>
</blockquote>
<blockquote>
<p>是这样的。所有的问题行为，例如逃学或者割腕以及未成年人饮酒或吸烟等，一切都是“廉价的优越性追求”。你刚开始提到的那位闭门不出的朋友也是一样。</p>
</blockquote>
<h5 id="◆-甘于平凡的勇气"><a href="#◆-甘于平凡的勇气" class="headerlink" title="◆ 甘于平凡的勇气"></a>◆ 甘于平凡的勇气</h5><blockquote>
<p>拒绝普通的你也许是把“普通”理解成了“无能”吧。普通并不等于无能，我们根本没必要特意炫耀自己的优越性。</p>
</blockquote>
<h5 id="◆-人生是一连串的刹那"><a href="#◆-人生是一连串的刹那" class="headerlink" title="◆ 人生是一连串的刹那"></a>◆ 人生是一连串的刹那</h5><blockquote>
<p>不了解这一点的大人们总是想要强迫年轻人过“线”一样的人生。在他们看来，上好大学、进好企业、拥有稳定的家庭，这样的轨道才是幸福的人生。但是，人生不可能是一条线。</p>
</blockquote>
<h5 id="◆-舞动人生"><a href="#◆-舞动人生" class="headerlink" title="◆ 舞动人生"></a>◆ 舞动人生</h5><blockquote>
<p>请你这样想。人生就像是在每一个瞬间不停旋转起舞的连续的刹那。并且，暮然四顾时常常会惊觉：“已经来到这里了吗？”</p>
</blockquote>
<blockquote>
<p>如果是这样的话，那就不能称为旅行。跨出家门的那一瞬间，“旅行”已经开始，朝着目的地出发途中的每一个瞬间都是旅行。当然，即使因为某些事情而没能够到达金字塔，那也并非没有旅行。这就是现实性的人生。</p>
</blockquote>
<h5 id="◆-最重要的是“此时此刻”"><a href="#◆-最重要的是“此时此刻”" class="headerlink" title="◆ 最重要的是“此时此刻”"></a>◆ 最重要的是“此时此刻”</h5><blockquote>
<p>我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。</p>
</blockquote>
<blockquote>
<p>是的。我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。</p>
</blockquote>
<blockquote>
<p>人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根本不会说出那样的话。</p>
</blockquote>
<h5 id="◆-对决“人生最大的谎言”"><a href="#◆-对决“人生最大的谎言”" class="headerlink" title="◆ 对决“人生最大的谎言”"></a>◆ 对决“人生最大的谎言”</h5><blockquote>
<p>你自己的人生也同样。为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。因为在这种情况下，人就会认为“此时此刻”只是准备阶段和忍耐阶段。<br>但是，为了遥远将来的考试而努力学习的“此时此刻”却是真实的存在。</p>
</blockquote>
<blockquote>
<p>你还有我，即使生命终结于“此时此刻”，那也并不足以称为不幸。无论是20岁终结的人生还是90岁终结的人生，全都是完结的、幸福的人生。</p>
</blockquote>
<blockquote>
<p>人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。<br>青年：……啊！</p>
</blockquote>
]]></content>
      <categories>
        <category>书</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>关于单身，早恋，催婚想说的话</title>
    <url>/2020/08/10/%E5%85%B3%E4%BA%8E%E5%8D%95%E8%BA%AB%EF%BC%8C%E6%97%A9%E6%81%8B%EF%BC%8C%E5%82%AC%E5%A9%9A%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
    <content><![CDATA[<p><strong>写在开头</strong><br>昨天刷b站的时候，看到了很多催婚催生的视频，这类视频的点击量的骤增往往集中于1-2月，也就是过年的时候，原因想必也不言而喻。很多人应该都有过这样的画面：一群亲戚围着你，有满脸通红拿着酒杯的，有啃着瓜子翘着腿的，“和蔼可亲”地问你：有对象了吗？如果有对象了，他们会接着拷问对象的个人信息，围绕职业和长相两个核心点，对你旁敲侧击。不过你不要以为他们的关注点在你身上，当你说出我有对象了之后，他们真正的战略重心就转移到了你爸妈身上，和你接下去的对话只是一个过渡。他们最终一定会笑容满面地和你爸妈进行更深一步的沟通。</p>
<p><strong>“早恋”和“应该有对象”中间有过渡期吗？</strong><br>根据我的观察，大多数的父母不允许孩子在中学阶段谈恋爱；少数父母嘴上说着允许，等你有了行动之后采取行动；较少数父母在孩子成绩较好的情况下允许，当成绩下滑时将矛头第一个指向早恋；极少数父母对此完全赞同。当然，这只是我个人所处环境的情况，可以理解为统计学上的一个点，并不是绝对的。</p>
<p>但是，当孩子上了大学，为什么长辈们的观念马上就变成了：你有没有男朋友，女朋友？or 你为什么不去找一个？</p>
<p>这些话如果没有媒体的推波助澜，其实并不会让我们太反感。但打开手机，今天看到的是“大学阶段不谈段恋爱是一辈子的遗憾”，明天看到的是“一个人也能活得很精彩”。这些话先不论对错，但在我们的心上留了个定时炸弹，当我们失恋、被催婚···时爆发。</p>
<p>于是不禁产生了一个疑问，“早恋”和“应该有对象”之间有过渡期吗？在高考结束前的一秒钟，我们的恋爱行为被称为早恋，在高考成绩出来后，我们保持单身的行为会在某些时刻给自己带来压力，why？在高考结束前后短短的几个月时间，我们的心智应该不会有如此突飞猛进的成熟吧。</p>
<p><strong>想对部分长辈们说的话</strong><br>生活中还是有很多开明的老师和长辈，但也不乏一些思想僵化、空洞无聊的灵魂。我很幸运的是每次过年回去并没有收到太多灵魂拷问，但听到很多好朋友和我说亲戚们的一些神操作。如果是女生，一些长辈竟然会说出：女孩子再不找个男朋友以后找不到了。我们才20出头啊，似乎明天就人老珠黄了一样。关键点不在这里，</p>
]]></content>
  </entry>
  <entry>
    <title>PAT A1032 Sharing</title>
    <url>/2020/07/17/PAT%20A1051.Pop%20Sequence/</url>
    <content><![CDATA[<h2 id="1051-Pop-Sequence-25分"><a href="#1051-Pop-Sequence-25分" class="headerlink" title="1051 Pop Sequence (25分)"></a>1051 Pop Sequence (25分)</h2><p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 7 5</p>
<p>1 2 3 4 5 6 7</p>
<p>3 2 1 7 5 6 4</p>
<p>7 6 5 4 3 2 1</p>
<p>5 6 4 3 7 2 1</p>
<p>1 7 6 5 4 3 2</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>YES</p>
<p>NO</p>
<p>NO</p>
<p>YES</p>
<p>NO</p>
<h2 id="need-attention"><a href="#need-attention" class="headerlink" title="need attention"></a>need attention</h2><p>这道题大意是判断哪些输入是合法的栈输出顺序，思路也很简单：开一个数组记录题目所给出栈顺序，开一个栈。依次将1-n入栈，当入栈元素和数组元素有相同的，则出栈，并将数组往后移位。需要注意每次循环要把栈清空，temp还原。并且在每次出栈时要判断栈是否为空。</p>
<h2 id="My-code"><a href="#My-code" class="headerlink" title="My code"></a>My code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;st; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,n,k;<span class="comment">//temp用来迭代题目所给出栈序列 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">	<span class="keyword">while</span>(k--)<span class="comment">//k组数据 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!st.empty())<span class="comment">//清空栈 </span></span><br><span class="line">		st.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">		&#125;<span class="comment">//读入数据 </span></span><br><span class="line">		<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			st.push(i);</span><br><span class="line">			<span class="keyword">if</span>(st.<span class="built_in">size</span>()&gt;m)<span class="comment">//超过stack容量</span></span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(!st.empty()&amp;&amp;st.top()==arr[temp])</span><br><span class="line">			&#123;</span><br><span class="line">				st.pop();</span><br><span class="line">				temp++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag&amp;&amp;st.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1056 Mice and Rice</title>
    <url>/2020/07/17/PAT%20A1056%20Mice%20and%20Rice/</url>
    <content><![CDATA[<h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><p>Mice and Rice is the name of a programming contest in which each programmer must write a piece of code to control the movements of a mouse in a given map. The goal of each mouse is to eat as much rice as possible in order to become a FatMouse.<br>First the playing order is randomly decided for N​P programmers. Then every N​G programmers are grouped in a match. The fattest mouse in a group wins and enters the next turn. All the losers in this turn are ranked the same. Every N​G winners are then grouped in the next match until a final winner is determined.<br>For the sake of simplicity, assume that the weight of each mouse is fixed once the programmer submits his/her code. Given the weights of all the mice and the initial playing order, you are supposed to output the ranks for the programmers.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains 2 positive integers: N​P and N​G(≤1000), the number of programmers and the maximum number of mice in a group, respectively. If there are less than N​G mice at the end of the player’s list, then all the mice left will be put into the last group. The second line contains N​P distinct non-negative numbers W​i (i=0,⋯,N​P​​ −1) where each W​i is the weight of the i-th mouse respectively. The third line gives the initial playing order which is a permutation of 0,⋯,N​P −1 (assume that the programmers are numbered from 0 to NP −1). All the numbers in a line are separated by a space.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, print the final ranks in a line. The i-th number is the rank of the i-th programmer, and all the numbers must be separated by a space, with no extra space at the end of the line.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>11 3</p>
<p>25 18 0 46 37 3 19 22 57 56 10</p>
<p>6 0 8 7 10 5 9 1 4 2 3</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>5 5 5 2 5 5 5 3 1 3 5</p>
<h2 id="need-attention"><a href="#need-attention" class="headerlink" title="need attention"></a>need attention</h2><p>首先，这道题为什么会想到队列呢？小老鼠比赛完之后，获胜的将晋级下一轮，而失败的会被淘汰。这就可以用队列实现：依次比较完后，让获胜的重新入队，而失败的就pop出去。需要注意的是，while里面的两层for循环，和if(i*m+j&gt;=temp)这条语句，当每轮比赛老鼠不足时，需要跳出循环。并且式子中是大于等于，因为是从0开始遍历的。最后，还要注意temp的每次更新。 </p>
<h2 id="My-code"><a href="#My-code" class="headerlink" title="My code"></a>My code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mice</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">int</span> rank;</span><br><span class="line">&#125;mice[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mice[i].weight);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;order);</span><br><span class="line">		q.push(order);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp=n,group;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp%m==<span class="number">0</span>)</span><br><span class="line">		group=temp/m;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		group=temp/m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;group;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> k=q.front();<span class="comment">//k存放该组质量最大老鼠的编号 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i*m+j&gt;=temp)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">int</span> front=q.front();</span><br><span class="line">				<span class="keyword">if</span>(mice[front].weight&gt;mice[k].weight)</span><br><span class="line">				k=front;</span><br><span class="line">				mice[front].rank=group+<span class="number">1</span>;</span><br><span class="line">				q.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			q.push(k);</span><br><span class="line">		&#125;</span><br><span class="line">		temp=group;</span><br><span class="line">	&#125;</span><br><span class="line">	mice[q.front()].rank=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,mice[i].rank);</span><br><span class="line">		<span class="keyword">if</span>(i!=n<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习（一）数据库的相关概念及MySQL的介绍</title>
    <url>/2020/07/17/MySQL%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8AMySQL%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h1><h2 id="一、数据库的好处"><a href="#一、数据库的好处" class="headerlink" title="一、数据库的好处"></a>一、数据库的好处</h2><p>1、可以持久化数据到本地</p>
<p>2、结构化查询</p>
<h2 id="二、数据库的常见概念-★"><a href="#二、数据库的常见概念-★" class="headerlink" title="二、数据库的常见概念 ★"></a>二、数据库的常见概念 ★</h2><p>1、DB：数据库，存储数据的容器</p>
<p>2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB</p>
<p>3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p>
<h2 id="三、数据库存储数据的特点"><a href="#三、数据库存储数据的特点" class="headerlink" title="三、数据库存储数据的特点"></a>三、数据库存储数据的特点</h2><p>1、数据存放到表（table）中，然后表再放到库中</p>
<p>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己</p>
<p>3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”</p>
<p>4、表中的每一行数据，相当于java中“对象”</p>
<h2 id="四、常见的数据库管理系统"><a href="#四、常见的数据库管理系统" class="headerlink" title="四、常见的数据库管理系统"></a>四、常见的数据库管理系统</h2><p>mysql、oracle、db2、sqlserver</p>
<h1 id="MySQL的介绍"><a href="#MySQL的介绍" class="headerlink" title="MySQL的介绍"></a>MySQL的介绍</h1><h2 id="一、MySQL的背景"><a href="#一、MySQL的背景" class="headerlink" title="一、MySQL的背景"></a>一、MySQL的背景</h2><p>前身属于瑞典的一家公司，MySQL AB</p>
<p>08年被sun公司收购</p>
<p>09年sun被oracle收购</p>
<h2 id="二、MySQL的优点"><a href="#二、MySQL的优点" class="headerlink" title="二、MySQL的优点"></a>二、MySQL的优点</h2><p>1、开源、免费、成本低</p>
<p>2、性能高、移植性也好</p>
<p>3、体积小，便于安装</p>
<h2 id="三、MySQL服务的启动和停止"><a href="#三、MySQL服务的启动和停止" class="headerlink" title="三、MySQL服务的启动和停止"></a>三、MySQL服务的启动和停止</h2><p>方式一：通过命令行<br>    net start 服务名<br>    net stop 服务名</p>
<p>方式二：计算机——右击——管理——服务</p>
<h2 id="五、MySQL服务的登录和退出"><a href="#五、MySQL服务的登录和退出" class="headerlink" title="五、MySQL服务的登录和退出"></a>五、MySQL服务的登录和退出</h2><p>登录：mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</p>
<p>退出：exit或ctrl+C</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1074 Reversing Linked List</title>
    <url>/2020/07/17/PAT%20A1074%20Reversing%20Linked%20List/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (≤10<br>​5<br>​​ ) which is the total number of nodes, and a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Data Next<br>where Address is the position of the node, Data is an integer, and Next is the position of the next node.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>00100 6 4</p>
<p>00000 4 99999</p>
<p>00100 1 12309</p>
<p>68237 6 -1 </p>
<p>33218 3 00000</p>
<p>99999 5 68237</p>
<p>12309 2 33218</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>00000 4 33218</p>
<p>33218 3 12309</p>
<p>12309 2 00100</p>
<p>00100 1 99999</p>
<p>99999 5 68237</p>
<p>68237 6 -1</p>
<h2 id="need-attention"><a href="#need-attention" class="headerlink" title="need attention"></a>need attention</h2><p>在处理i号块的最后一个结点时，需要考虑</p>
<ol>
<li>i号块是否是最后一个完整块，如果不是，那么next就是（i+2）*k-1号结点，也就是i+1号块的最后一个结点</li>
<li>如果i号块是最后一个完整快，那么要分为count%k是否为0（后面有没有需要正序输出的）</li>
<li>%05d的输出格式会使-1的输出出现问题，所以要单独输出-1，不能用node[i].adress这样的格式输出。</li>
</ol>
<h2 id="My-code"><a href="#My-code" class="headerlink" title="My code"></a>My code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//define static linked list </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adress;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">	<span class="comment">//the order of node in the linked list,assign invalid node maxn</span></span><br><span class="line"> 	<span class="keyword">int</span> order;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.order&lt;b.order;<span class="comment">//order by "order"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> origin_adress,n,k;</span><br><span class="line">	<span class="comment">//maybe some of nodes are of no avail,disconnected with the given data</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		node[i].order=maxn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;origin_adress,&amp;n,&amp;k);</span><br><span class="line">	<span class="comment">//input </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> adress;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;adress);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;node[adress].data,&amp;node[adress].next);</span><br><span class="line">		node[adress].adress=adress;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//begin with the origin_adress,check if the node is correct by order</span></span><br><span class="line">	<span class="keyword">int</span> p=origin_adress,count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		node[p].order=count++;</span><br><span class="line">		p=node[p].next;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(node,node+maxn,cmp);</span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="comment">//i block</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count/k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//the last block consider independently </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=(i+<span class="number">1</span>)*k<span class="number">-1</span>;j&gt;i*k;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,node[j].adress,node[j].data,node[j<span class="number">-1</span>].adress);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//the last block</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%05d %d "</span>,node[i*k].adress,node[i*k].data);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;count/k<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,node[(i+<span class="number">2</span>)*k<span class="number">-1</span>].adress);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(count%k==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,node[(i+<span class="number">1</span>)*k].adress);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=count/k*k;i&lt;count;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i&lt;count<span class="number">-1</span>)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,node[i].adress,node[i].data,node[i+<span class="number">1</span>].adress);</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,node[i].adress,node[i].data);	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1052 Linked List Sorting</title>
    <url>/2020/07/17/PAT%20A1052%20Linked%20List%20Sorting/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains a positive N (&lt;10<br>​5<br>​​ ) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Key Next<br>where Address is the address of the node in memory, Key is an integer in [−10<br>​5<br>​​ ,10<br>​5<br>​​ ], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>5 00001</p>
<p>11111 100 -1</p>
<p>00001 0 22222</p>
<p>33333 100000 11111</p>
<p>12345 -1 33333</p>
<p>22222 1000 12345</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>5 12345</p>
<p>12345 -1 00001</p>
<p>00001 0 11111</p>
<p>11111 100 22222</p>
<p>22222 1000 33333</p>
<p>33333 100000 -1</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><ol>
<li>sort排序时，第二个参数是+maxn，而不是+count，因为是静态链表按下标存储，要把所有节点排序。</li>
<li>要注意count为0的情况，即所有节点都是无效结点。</li>
</ol>
<h2 id="MyCode"><a href="#MyCode" class="headerlink" title="MyCode"></a>MyCode</h2><p>```C++<br>#include<cstdio><br>#include<algorithm><br>const int maxn=100005;<br>using namespace std;<br>struct Node{<br>    int adress;<br>    int value;<br>    int next;<br>    int flag=0;<br>}da[maxn];<br>bool cmp(Node a,Node b)<br>{<br>    if(a.flag!=b.flag)<br>    return a.flag&gt;b.flag;<br>    else<br>    return a.value&lt;b.value;<br>}<br>int main()<br>{<br>    int n,start,adress;<br>    scanf(“%d%d”,&amp;n,&amp;start);<br>    //input<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        scanf(“%d”,&amp;adress);<br>        scanf(“%d %d”,&amp;da[adress].value,&amp;da[adress].next);<br>        da[adress].adress=adress;<br>    }<br>    int p=start,count=0;<br>    while(p!=-1)<br>    {<br>        da[p].flag=1;<br>        p=da[p].next;<br>        count++;<br>    }<br>    sort(da,da+maxn,cmp);<br>    if(count==0)<br>    printf(“0 -1\n”);<br>    else<br>    printf(“%d %05d\n”,count,da[0].adress);<br>    for(int i=0;i&lt;count;i++)<br>    {<br>        if(i==count-1)<br>        printf(“%05d %d -1\n”,da[i].adress,da[i].value);<br>        else<br>        printf(“%05d %d %05d\n”,da[i].adress,da[i].value,da[i+1].adress);<br>    }<br>    return 0;<br>}</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1032 Sharing</title>
    <url>/2020/07/17/PAT%20A1032%20Sharing/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, loading and being are stored as showed in Figure 1.</p>
<p>You are supposed to find the starting position of the common suffix (e.g. the position of i in Figure 1).</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (≤10<br>​5<br>​​ ), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Data Next<br>whereAddress is the position of the node, Data is the letter contained by this node which is an English letter chosen from { a-z, A-Z }, and Next is the position of the next node.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output -1 instead.</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h2><p>11111 22222 9</p>
<p>67890 i 00002</p>
<p>00010 a 12345</p>
<p>00003 g -1</p>
<p>12345 D 67890</p>
<p>00002 n 00003</p>
<p>22222 B 23456</p>
<p>11111 L 00001</p>
<p>23456 e 67890</p>
<p>00001 o 00010</p>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h2><p>67890</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h2><p>00001 00002 4</p>
<p>00001 a 10001</p>
<p>10001 s -1</p>
<p>00002 a 10002</p>
<p>10002 t -1</p>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h2><p>-1</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p>%c在读入数据时会读入空格，要小心。</p>
<h2 id="MyCode"><a href="#MyCode" class="headerlink" title="MyCode"></a>MyCode</h2><p>```C++<br>#include<cstdio><br>const int maxn=100005;<br>struct Word{<br>    int adress;<br>    char data;<br>    int next;<br>    int flag=-1;<br>}word[maxn];<br>int main()<br>{<br>    int start1,start2,n;<br>    scanf(“%d %d %d”,&amp;start1,&amp;start2,&amp;n);<br>    //input<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        int adress;<br>        scanf(“%d”,&amp;adress);<br>        scanf(“ %c %d”,&amp;word[adress].data,&amp;word[adress].next);<br>        word[adress].adress=adress;<br>    }<br>    //traversal<br>    int p=start1;<br>    while(p!=-1)<br>    {<br>        word[p].flag=1;<br>        p=word[p].next;<br>    }<br>//    find the same suffix<br>    p=start2;<br>//    check if the same suffix appear<br>    int flag1=0;<br>    while(p!=-1)<br>    {<br>        if(word[p].flag==1)<br>        {<br>            flag1=1;<br>            break;<br>        }<br>        p=word[p].next;<br>    }<br>    if(flag1==1)<br>    printf(“%05d\n”,p);<br>    else<br>    printf(“-1\n”);<br>    return 0;<br>}</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1001 A+B Format</title>
    <url>/2020/07/17/PAT%20A1001%20A+B%20Format/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. Each case contains a pair of integers a and b where −10<br>​6<br>​​ ≤a,b≤10<br>​6<br>​​ . The numbers are separated by a space.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>-1000000 9</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>-999,991</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p>输入为0 0的时候要小心~</p>
<h2 id="MyCode"><a href="#MyCode" class="headerlink" title="MyCode"></a>MyCode</h2><p>```C++<br>#include<cstdio><br>int arr[10000000];<br>int main()<br>{<br>    int a,b,sum;<br>    scanf(“%d %d”,&amp;a,&amp;b);<br>    sum=a+b;<br>    if(sum==0)<br>    {<br>        printf(“0\n”);<br>        return 0;<br>    }<br>    int flag=0;//positive digit<br>    if(sum&lt;0)<br>    {<br>        flag=1;<br>        sum=-sum;<br>    }<br>    int i=0;<br>    while(sum!=0)<br>    {<br>        arr[i++]=sum%10;<br>        sum/=10;<br>    }<br>    if(flag==1)<br>    printf(“-“);<br>    for(int j=i-1;j&gt;=0;j–)<br>    {<br>        printf(“%d”,arr[j]);<br>        if(j%3==0&amp;&amp;j!=0)<br>        printf(“,”);<br>    }<br>    printf(“\n”);<br>}</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1097 Deduplication on a Linked List</title>
    <url>/2020/07/17/PAT%20A1097%20Deduplication%20on%20a%20Linked%20List/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (≤10<br>​5<br>​​ ) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by −1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p>Address Key Next<br>where Address is the position of the node, Key is an integer of which absolute value is no more than 10<br>​4<br>​​ , and Next is the position of the next node.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>00100 5</p>
<p>99999 -7 87654</p>
<p>23854 -15 00000</p>
<p>87654 15 -1</p>
<p>00000 -15 99999</p>
<p>00100 21 23854</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>00100 21 23854</p>
<p>23854 -15 99999</p>
<p>99999 -7 -1</p>
<p>00000 -15 87654</p>
<p>87654 15 -1</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p>这题的主要思想是：把无效结点的order初始值赋为2maxn，把多余的结点order从manx开始排序，需要的结点从0开始排序，这样就可以区分三者。</p>
<h2 id="MyCode"><a href="#MyCode" class="headerlink" title="MyCode"></a>MyCode</h2><p>```C++<br>#include<cstdio><br>#include<cmath><br>#include<algorithm><br>using namespace std;<br>const int maxn=100005;<br>bool isExit[100005]={false};<br>struct Node{<br>    int adress;<br>    int value;<br>    int next;<br>    int order=2*maxn;<br>}da[maxn];<br>bool cmp(Node a,Node b)<br>{<br>    return a.order&lt;b.order;<br>}<br>int main()<br>{<br>    int n,start;<br>    scanf(“%d %d”,&amp;start,&amp;n);<br>    int adress;<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        scanf(“%d”,&amp;adress);<br>        scanf(“%d %d”,&amp;da[adress].value,&amp;da[adress].next);<br>        da[adress].adress=adress;<br>    }<br>    int p=start;<br>    int count1=0,count2=0;<br>    while(p!=-1)<br>    {<br>        if(isExit[abs(da[p].value)]==0)<br>        da[p].order=count1++;//ÓÐcount1¸öÃ»ÖØ¸´µÄ<br>        else<br>        da[p].order=maxn+(count2++);//ÓÐcount2¸öÖØ¸´µÄ<br>        isExit[abs(da[p].value)]=1;<br>        p=da[p].next;<br>    }<br>    sort(da,da+maxn,cmp);<br>    for(int i=0;i&lt;count1;i++)<br>    {<br>        if(i==count1-1)<br>        printf(“%05d %d -1\n”,da[i].adress,da[i].value);<br>        else<br>        printf(“%05d %d %05d\n”,da[i].adress,da[i].value,da[i+1].adress);<br>    }<br>    for(int i=count1;i&lt;count1+count2;i++)<br>    {<br>        if(i==count1+count2-1)<br>        printf(“%05d %d -1\n”,da[i].adress,da[i].value);<br>        else<br>        printf(“%05d %d %05d\n”,da[i].adress,da[i].value,da[i+1].adress);<br>    }<br>}</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>静态链表</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT A1002 A+B for Polynomials</title>
    <url>/2020/07/17/PAT%20A1002%20A+B%20for%20Polynomials/</url>
    <content><![CDATA[<h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>This time, you are supposed to find A+B where A and B are two polynomials.</p>
<h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p>
<p>K N<br>​1<br>​​  a<br>​N<br>​1<br>​​<br>​​  N<br>​2<br>​​  a<br>​N<br>​2<br>​​<br>​​  … N<br>​K<br>​​  a<br>​N<br>​K<br>​​<br>​​ </p>
<p>where K is the number of nonzero terms in the polynomial, N<br>​i<br>​​  and a<br>​N<br>​i<br>​​<br>​​  (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N<br>​K<br>​​ &lt;⋯&lt;N<br>​2<br>​​ &lt;N<br>​1<br>​​ ≤1000.</p>
<h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h2><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h2><p>2 1 2.4 0 3.2</p>
<p>2 2 1.5 1 0.5</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h2><p>3 2 1.5 1 2.9 0 3.2</p>
<h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><p>count的大小不能在输入时就判断，因为一正一负抵消为0的情况比较难处理</p>
<h2 id="MyCode"><a href="#MyCode" class="headerlink" title="MyCode"></a>MyCode</h2><p>```C++<br>#include<cstdio><br>const int maxn=1005;<br>double a[maxn];<br>int main()<br>{<br>    int n,k,count=0;<br>    double p=0.0;<br>    for(int i=0;i&lt;2;i++)<br>    {<br>        scanf(“%d”,&amp;n);<br>        for(int j=0;j&lt;n;j++)<br>        {<br>            scanf(“%d”,&amp;k);<br>            scanf(“%lf”,&amp;p);<br>            a[k]+=p;<br>        }<br>    }<br>    for(int i=0;i&lt;maxn;i++)<br>    {<br>        if(a[i]!=0)<br>        count++;<br>    }<br>    if(count==0)<br>    printf(“0\n”);<br>    else<br>    printf(“%d “,count);<br>    int q=maxn-1,z=1;<br>    while(q&gt;=0)<br>    {<br>        if(a[q]!=0&amp;&amp;z==count)<br>        {<br>            printf(“%d %.1f\n”,q,a[q]);<br>            z++;<br>            break;<br>        }<br>        if(a[q]!=0)<br>        {<br>            printf(“%d %.1f “,q,a[q]);<br>            z++;<br>        }<br>        q–;<br>    }<br>}</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>简单模拟</tag>
      </tags>
  </entry>
</search>
